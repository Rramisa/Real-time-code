{"ast":null,"code":"export const CACHE_PREFIX = 'react-avatar/';\nexport const CACHE_KEY_FAILING = 'failing';\nconst _hasLocalStorage = function isLocalStorageAvailable() {\n  try {\n    return 'localStorage' in window && window['localStorage'];\n  } catch (err) {\n    return false;\n  }\n}();\nexport class Cache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      cachePrefix = CACHE_PREFIX,\n      sourceTTL = 7 * 24 * 3600 * 1000,\n      sourceSize = 20\n    } = options;\n    this.cachePrefix = cachePrefix;\n    this.sourceTTL = sourceTTL;\n    this.sourceSize = sourceSize;\n  }\n  set(key, value) {\n    // cache not available\n    if (!_hasLocalStorage) return;\n    value = JSON.stringify(value);\n    try {\n      localStorage.setItem(this.cachePrefix + key, value);\n    } catch (e) {\n      // failsafe for mobile Safari private mode\n      console.error(e); // eslint-disable-line no-console\n    }\n  }\n  get(key) {\n    // cache not available\n    if (!_hasLocalStorage) return null;\n    const value = localStorage.getItem(this.cachePrefix + key);\n    if (value) return JSON.parse(value);\n    return null;\n  }\n  sourceFailed(source) {\n    let cacheList = this.get(CACHE_KEY_FAILING) || [];\n\n    // Remove expired entries or previous instances of this source\n    cacheList = cacheList.filter(entry => {\n      const hasExpired = entry.expires > 0 && entry.expires < Date.now();\n      const isMatch = entry === source || entry.url == source;\n      return !hasExpired && !isMatch;\n    });\n\n    // Add the source to the end of the list\n    cacheList.unshift({\n      url: source,\n      expires: Date.now() + this.sourceTTL\n    });\n\n    // only keep the last X results so we don't fill up local storage\n    cacheList = cacheList.slice(0, this.sourceSize - 1);\n    return this.set(CACHE_KEY_FAILING, cacheList);\n  }\n  hasSourceFailedBefore(source) {\n    const cacheList = this.get(CACHE_KEY_FAILING) || [];\n    return cacheList.some(entry => {\n      const hasExpired = entry.expires > 0 && entry.expires < Date.now();\n      const isMatch = entry === source || entry.url == source;\n      return isMatch && !hasExpired;\n    });\n  }\n}\nexport default new Cache();","map":{"version":3,"names":["CACHE_PREFIX","CACHE_KEY_FAILING","_hasLocalStorage","isLocalStorageAvailable","window","err","Cache","constructor","options","arguments","length","undefined","cachePrefix","sourceTTL","sourceSize","set","key","value","JSON","stringify","localStorage","setItem","e","console","error","get","getItem","parse","sourceFailed","source","cacheList","filter","entry","hasExpired","expires","Date","now","isMatch","url","unshift","slice","hasSourceFailedBefore","some"],"sources":["/Users/sumonta/Downloads/CSE471_Group8-main/frontend/node_modules/react-avatar/es/cache.js"],"sourcesContent":["export const CACHE_PREFIX = 'react-avatar/';\nexport const CACHE_KEY_FAILING = 'failing';\nconst _hasLocalStorage = function isLocalStorageAvailable() {\n  try {\n    return 'localStorage' in window && window['localStorage'];\n  } catch (err) {\n    return false;\n  }\n}();\nexport class Cache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      cachePrefix = CACHE_PREFIX,\n      sourceTTL = 7 * 24 * 3600 * 1000,\n      sourceSize = 20\n    } = options;\n    this.cachePrefix = cachePrefix;\n    this.sourceTTL = sourceTTL;\n    this.sourceSize = sourceSize;\n  }\n  set(key, value) {\n    // cache not available\n    if (!_hasLocalStorage) return;\n    value = JSON.stringify(value);\n    try {\n      localStorage.setItem(this.cachePrefix + key, value);\n    } catch (e) {\n      // failsafe for mobile Safari private mode\n      console.error(e); // eslint-disable-line no-console\n    }\n  }\n  get(key) {\n    // cache not available\n    if (!_hasLocalStorage) return null;\n    const value = localStorage.getItem(this.cachePrefix + key);\n    if (value) return JSON.parse(value);\n    return null;\n  }\n  sourceFailed(source) {\n    let cacheList = this.get(CACHE_KEY_FAILING) || [];\n\n    // Remove expired entries or previous instances of this source\n    cacheList = cacheList.filter(entry => {\n      const hasExpired = entry.expires > 0 && entry.expires < Date.now();\n      const isMatch = entry === source || entry.url == source;\n      return !hasExpired && !isMatch;\n    });\n\n    // Add the source to the end of the list\n    cacheList.unshift({\n      url: source,\n      expires: Date.now() + this.sourceTTL\n    });\n\n    // only keep the last X results so we don't fill up local storage\n    cacheList = cacheList.slice(0, this.sourceSize - 1);\n    return this.set(CACHE_KEY_FAILING, cacheList);\n  }\n  hasSourceFailedBefore(source) {\n    const cacheList = this.get(CACHE_KEY_FAILING) || [];\n    return cacheList.some(entry => {\n      const hasExpired = entry.expires > 0 && entry.expires < Date.now();\n      const isMatch = entry === source || entry.url == source;\n      return isMatch && !hasExpired;\n    });\n  }\n}\nexport default new Cache();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}