{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { Cache } from './cache';\nimport { withConfig, ConfigProvider } from './context';\nimport InternalState from './internal-state';\nexport { getRandomColor } from './utils';\nexport { ConfigProvider } from './context';\nexport { Cache } from './cache';\nfunction matchSource(Source, props, cb) {\n  const {\n    cache\n  } = props;\n  const instance = new Source(props);\n  if (!instance.isCompatible(props)) return cb();\n  instance.get(state => {\n    const failedBefore = state && state.src && cache.hasSourceFailedBefore(state.src);\n    if (!failedBefore && state) {\n      cb(state);\n    } else {\n      cb();\n    }\n  });\n}\nexport default function createAvatarDataProvider(_ref) {\n  let {\n    sources = []\n  } = _ref;\n  // Collect propTypes for each individual source\n  const sourcePropTypes = sources.reduce((r, s) => Object.assign(r, s.propTypes), {});\n  class AvatarDataProvider extends PureComponent {\n    constructor(props) {\n      super(props);\n      _defineProperty(this, \"_createFetcher\", internal => errEvent => {\n        const {\n          cache\n        } = this.props;\n        if (!internal.isActive(this.state)) return;\n\n        // Mark img source as failed for future reference\n        if (errEvent && errEvent.type === 'error') cache.sourceFailed(errEvent.target.src);\n        const pointer = internal.sourcePointer;\n        if (sources.length === pointer) return;\n        const source = sources[pointer];\n        internal.sourcePointer++;\n        matchSource(source, this.props, nextState => {\n          if (!nextState) return setTimeout(internal.fetch, 0);\n          if (!internal.isActive(this.state)) return;\n\n          // Reset other values to prevent them from sticking (#51)\n          nextState = {\n            src: null,\n            value: null,\n            color: null,\n            ...nextState\n          };\n          this.setState(state => {\n            // Internal state has been reset => we received new props\n            return internal.isActive(state) ? nextState : {};\n          });\n        });\n      });\n      _defineProperty(this, \"fetch\", () => {\n        const internal = new InternalState();\n        internal.fetch = this._createFetcher(internal);\n        this.setState({\n          internal\n        }, internal.fetch);\n      });\n      this.state = {\n        internal: null,\n        src: null,\n        value: null,\n        color: props.color\n      };\n    }\n    componentDidMount() {\n      this.fetch();\n    }\n    componentDidUpdate(prevProps) {\n      let needsUpdate = false;\n\n      // This seems redundant\n      //\n      // Props that need to be in `state` are\n      // `value`, `src` and `color`\n      for (const prop in sourcePropTypes) needsUpdate = needsUpdate || prevProps[prop] !== this.props[prop];\n      if (needsUpdate) setTimeout(this.fetch, 0);\n    }\n    componentWillUnmount() {\n      if (this.state.internal) {\n        this.state.internal.active = false;\n      }\n    }\n    render() {\n      const {\n        children,\n        propertyName\n      } = this.props;\n      const {\n        src,\n        value,\n        color,\n        sourceName,\n        internal\n      } = this.state;\n      const avatarData = {\n        src,\n        value,\n        color,\n        sourceName,\n        onRenderFailed: () => internal && internal.fetch() // eslint-disable-line\n      };\n      if (typeof children === 'function') return children(avatarData);\n      const child = React.Children.only(children);\n      return /*#__PURE__*/React.cloneElement(child, {\n        [propertyName]: avatarData\n      });\n    }\n  }\n  _defineProperty(AvatarDataProvider, \"displayName\", 'AvatarDataProvider');\n  _defineProperty(AvatarDataProvider, \"propTypes\", {\n    // PropTypes defined on sources\n    ...sourcePropTypes,\n    cache: PropTypes.object,\n    propertyName: PropTypes.string\n  });\n  _defineProperty(AvatarDataProvider, \"defaultProps\", {\n    propertyName: 'avatar'\n  });\n  _defineProperty(AvatarDataProvider, \"Cache\", Cache);\n  _defineProperty(AvatarDataProvider, \"ConfigProvider\", ConfigProvider);\n  return Object.assign(withConfig(AvatarDataProvider), {\n    ConfigProvider,\n    Cache\n  });\n}","map":{"version":3,"names":["_defineProperty","React","PureComponent","PropTypes","Cache","withConfig","ConfigProvider","InternalState","getRandomColor","matchSource","Source","props","cb","cache","instance","isCompatible","get","state","failedBefore","src","hasSourceFailedBefore","createAvatarDataProvider","_ref","sources","sourcePropTypes","reduce","r","s","Object","assign","propTypes","AvatarDataProvider","constructor","internal","errEvent","isActive","type","sourceFailed","target","pointer","sourcePointer","length","source","nextState","setTimeout","fetch","value","color","setState","_createFetcher","componentDidMount","componentDidUpdate","prevProps","needsUpdate","prop","componentWillUnmount","active","render","children","propertyName","sourceName","avatarData","onRenderFailed","child","Children","only","cloneElement","object","string"],"sources":["/Users/sumonta/Downloads/CSE471_Group8-main/frontend/node_modules/react-avatar/es/data-provider.js"],"sourcesContent":["'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { Cache } from './cache';\nimport { withConfig, ConfigProvider } from './context';\nimport InternalState from './internal-state';\nexport { getRandomColor } from './utils';\nexport { ConfigProvider } from './context';\nexport { Cache } from './cache';\nfunction matchSource(Source, props, cb) {\n  const {\n    cache\n  } = props;\n  const instance = new Source(props);\n  if (!instance.isCompatible(props)) return cb();\n  instance.get(state => {\n    const failedBefore = state && state.src && cache.hasSourceFailedBefore(state.src);\n    if (!failedBefore && state) {\n      cb(state);\n    } else {\n      cb();\n    }\n  });\n}\nexport default function createAvatarDataProvider(_ref) {\n  let {\n    sources = []\n  } = _ref;\n  // Collect propTypes for each individual source\n  const sourcePropTypes = sources.reduce((r, s) => Object.assign(r, s.propTypes), {});\n  class AvatarDataProvider extends PureComponent {\n    constructor(props) {\n      super(props);\n      _defineProperty(this, \"_createFetcher\", internal => errEvent => {\n        const {\n          cache\n        } = this.props;\n        if (!internal.isActive(this.state)) return;\n\n        // Mark img source as failed for future reference\n        if (errEvent && errEvent.type === 'error') cache.sourceFailed(errEvent.target.src);\n        const pointer = internal.sourcePointer;\n        if (sources.length === pointer) return;\n        const source = sources[pointer];\n        internal.sourcePointer++;\n        matchSource(source, this.props, nextState => {\n          if (!nextState) return setTimeout(internal.fetch, 0);\n          if (!internal.isActive(this.state)) return;\n\n          // Reset other values to prevent them from sticking (#51)\n          nextState = {\n            src: null,\n            value: null,\n            color: null,\n            ...nextState\n          };\n          this.setState(state => {\n            // Internal state has been reset => we received new props\n            return internal.isActive(state) ? nextState : {};\n          });\n        });\n      });\n      _defineProperty(this, \"fetch\", () => {\n        const internal = new InternalState();\n        internal.fetch = this._createFetcher(internal);\n        this.setState({\n          internal\n        }, internal.fetch);\n      });\n      this.state = {\n        internal: null,\n        src: null,\n        value: null,\n        color: props.color\n      };\n    }\n    componentDidMount() {\n      this.fetch();\n    }\n    componentDidUpdate(prevProps) {\n      let needsUpdate = false;\n\n      // This seems redundant\n      //\n      // Props that need to be in `state` are\n      // `value`, `src` and `color`\n      for (const prop in sourcePropTypes) needsUpdate = needsUpdate || prevProps[prop] !== this.props[prop];\n      if (needsUpdate) setTimeout(this.fetch, 0);\n    }\n    componentWillUnmount() {\n      if (this.state.internal) {\n        this.state.internal.active = false;\n      }\n    }\n    render() {\n      const {\n        children,\n        propertyName\n      } = this.props;\n      const {\n        src,\n        value,\n        color,\n        sourceName,\n        internal\n      } = this.state;\n      const avatarData = {\n        src,\n        value,\n        color,\n        sourceName,\n        onRenderFailed: () => internal && internal.fetch() // eslint-disable-line\n      };\n      if (typeof children === 'function') return children(avatarData);\n      const child = React.Children.only(children);\n      return /*#__PURE__*/React.cloneElement(child, {\n        [propertyName]: avatarData\n      });\n    }\n  }\n  _defineProperty(AvatarDataProvider, \"displayName\", 'AvatarDataProvider');\n  _defineProperty(AvatarDataProvider, \"propTypes\", {\n    // PropTypes defined on sources\n    ...sourcePropTypes,\n    cache: PropTypes.object,\n    propertyName: PropTypes.string\n  });\n  _defineProperty(AvatarDataProvider, \"defaultProps\", {\n    propertyName: 'avatar'\n  });\n  _defineProperty(AvatarDataProvider, \"Cache\", Cache);\n  _defineProperty(AvatarDataProvider, \"ConfigProvider\", ConfigProvider);\n  return Object.assign(withConfig(AvatarDataProvider), {\n    ConfigProvider,\n    Cache\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}